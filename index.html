<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-135440090-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-135440090-1');
</script>



























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="不热爱写作的艺术家不是好程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="橘林">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="橘林">
<meta property="og:description" content="不热爱写作的艺术家不是好程序员">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="橘林">
<meta name="twitter:description" content="不热爱写作的艺术家不是好程序员">






  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>橘林</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">橘林</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/12/JS中的正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我摘青橘">
      <meta itemprop="description" content="不热爱写作的艺术家不是好程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘林">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/12/JS中的正则表达式/" class="post-title-link" itemprop="url">JS中的正则表达式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-12 14:00:00 / 修改时间：16:22:57" itemprop="dateCreated datePublished" datetime="2019-06-12T14:00:00+08:00">2019-06-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>总有一些知识是一看就会，一放就忘的，对我来说，正则表达式就是如此。学个入门不难，上手也快，不过由于我目前在工作学习中不太用到，往往看了之后过个几周也就忘了。也隔了两三个月没有更新博客了，所以趁着今天复习了一遍，写个blog，做一些总结，毕竟好记性不如烂键盘。</p>
<hr>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>正则表达式在不用的语言中有不用的写法，这篇文章主要介绍的是正则表达式在js中的写法和运用。不过万变不离其宗，各语言中的正则表达式的核心思想是类似的。均是使用一个 <strong>规则字符串</strong> 对字符串进行筛选和过滤，这个 <strong>规则字符串</strong> 用来表达对字符串的一种过滤逻辑。</p>
<hr>
<h3 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h3><p>在js中，可以用一下两种方式构建一个正则表达式</p>
<ol>
<li>使用一个正则表达式字面量，其由包含在斜杠之间的模式组成，如下所示：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   /pattern/flags</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/ab+c/</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^[a-zA-Z]+[0-9]*\W?_$/gi</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在加载脚本后，正则表达式字面量提供正则表达式的编译。当我们所使用的正则表达式在使用中不会发生变化时，使用此方法可获得更好的性能。</p>
<ol>
<li>调用RegExp对象的构造函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    new RegExp(pattern [, flags])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^[a-zA-Z]+[0-9]*\W?_$/</span>, <span class="string">"gi"</span>);</span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"ab+c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当使用字符串作为构造函数参数时，注意对"\"的转译，如需要使用"\d"时,应为"\\d"</span></span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"^[a-zA-Z]+[0-9]*\\W?_$"</span>, <span class="string">"gi"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当正则表达式会发生改变，或者你并不知道如何定义而需要从另一个来源获取时（如用户输入），可以使用构造函数。</p>
<hr>
<h3 id="正则表达式中的常见特殊字符"><a href="#正则表达式中的常见特殊字符" class="headerlink" title="正则表达式中的常见特殊字符"></a>正则表达式中的常见特殊字符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>1. 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释<br>     2. 反斜杠也可以将其后的特殊字符，转义为字面量<br>   <strong>3. 使用 new RegExp(“pattern”) 的时候不要忘记将 \ 进行转义，因为 \ 在字符串里面也是一个转义字符。</strong></td>
</tr>
<tr>
<td>^</td>
<td>匹配输入的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入的结束</td>
</tr>
<tr>
<td>*</td>
<td>匹配前一个表达式0次或多次。等价于 {0,}</td>
</tr>
<tr>
<td>+</td>
<td>匹配前一个表达式1次或多次。等价于 {1,}</td>
</tr>
<tr>
<td>？</td>
<td>1. 匹配前面一个表达式0次或者1次。等价于 {0,1}。<br> 2. 如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的<br> 3. 还可以运用于先行断言,如本表的 x(?=y) 和 x(?!y) 条目中所述</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符之外的任何单个字符</td>
</tr>
<tr>
<td>(x)</td>
<td>匹配 ‘x’ 并且记住匹配项，括号被称为捕获括号</td>
</tr>
<tr>
<td>(?:x)</td>
<td>匹配 ‘x’ 但是不记住匹配项,这种括号被称为非捕获括号</td>
</tr>
<tr>
<td>x(?=y)</td>
<td>匹配’x’仅仅当’x’后面跟着’y’，这种叫做先行断言</td>
</tr>
<tr>
<td>(?&lt;=y)x</td>
<td>匹配’x’仅仅当’x’前面是’y’，这种叫做后行断言</td>
</tr>
<tr>
<td>x(?!y)</td>
<td>匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找</td>
</tr>
<tr>
<td>x&#124;y</td>
<td>匹配‘x’或者‘y’</td>
</tr>
<tr>
<td>{n}</td>
<td>n是一个正整数，匹配了前面一个字符刚好发生了n次。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>1. 一个字符集合,匹配方括号中的任意字符，包括转义序列。<br> 2. 可以使用破折号（-）来指定一个字符范围,例如[abcd] 和[a-d]。<br> 3. 对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>1. 一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。<br> 2. 你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符</td>
</tr>
<tr>
<td>\s</td>
<td>匹配一个空白字符，包括空格、制表符、换页符和换行符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配一个非空白字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配一个单字字符（字母、数字或者下划线），等价于[A-Za-z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>匹配一个非单字字符,等价于<sup><a href="#fn_A-Za-z0-9_" id="reffn_A-Za-z0-9_">A-Za-z0-9_</a></sup></td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="正则表达式标志"><a href="#正则表达式标志" class="headerlink" title="正则表达式标志"></a>正则表达式标志</h3><div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>g</td>
<td>全局搜索</td>
</tr>
<tr>
<td>i</td>
<td>不区分大小写搜索</td>
</tr>
<tr>
<td>m</td>
<td>多行搜索</td>
</tr>
<tr>
<td>y</td>
<td>执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="使用正则表达式的方法"><a href="#使用正则表达式的方法" class="headerlink" title="使用正则表达式的方法"></a>使用正则表达式的方法</h3><p>主要有RegExp类型的exec和test方法以及String类型的march，replace，search和split方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="noopener">RegExp.exec()</a></td>
<td>1. 执行匹配，返回一个数组或null<br> 2. 当正则表达式使用 “g” 标志时，可以多次执行exec方法来查找同一个字符串中的成功匹配，此时查找将从正则表达式的 lastIndex 属性指定的位置开始。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test" target="_blank" rel="noopener">RegExp.test()</a></td>
<td>测试是否匹配,返回true或false</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match" target="_blank" rel="noopener">String.match()</a></td>
<td>返回一个数组或者在未匹配到时返回null</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search" target="_blank" rel="noopener">String.search()</a></td>
<td>返回匹配到的位置索引，或者在失败时返回-1</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="noopener">String.replace()</a></td>
<td>使用替换字符串替换掉匹配到的子字符串</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="noopener">String.split()</a></td>
<td>使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中并返回</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="使用括号的子字符串匹配"><a href="#使用括号的子字符串匹配" class="headerlink" title="使用括号的子字符串匹配"></a>使用括号的子字符串匹配</h3><p>一个正则表达式模式使用括号，将导致相应的子匹配被记住。例如，/a(b)c /可以匹配字符串“abc”，并且记得“b”。</p>
<p>例如模式/(foo) (bar) \1 \2/中的 ‘(foo)’ 和 ‘(bar)’ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 \1 和 \2 匹配字符串的后两个单词。注意 \1、\2、…、\n 这种写法是用在正则表达式的匹配环节。而在正则表达式的替换环节，则要使用像 &#36;1、&#36;2、…、&#36;n 这样的语法，代码如下所示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(\w+)\s(\w+)/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"John Smith"</span>;</span><br><span class="line"><span class="keyword">var</span> newstr = str.replace(re, <span class="string">"$2, $1"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newstr);</span><br></pre></td></tr></table></figure>
<p>这个表达式输出 “Smith, John”。</p>
<hr>
<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p><a href="https://www.jianshu.com/p/e7bb97218946?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends" target="_blank" rel="noopener">知道这20个正则表达式，能让你少写1,000行代码</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/二叉树三种遍历方式的代码实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我摘青橘">
      <meta itemprop="description" content="不热爱写作的艺术家不是好程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘林">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/二叉树三种遍历方式的代码实现/" class="post-title-link" itemprop="url">二叉树三种遍历方式的代码实现</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-28 16:00:00 / 修改时间：18:17:10" itemprop="dateCreated datePublished" datetime="2019-03-28T16:00:00+08:00">2019-03-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天在做算法题时碰到了熟悉的二叉树问题，说到二叉树就不得不提二叉树的三种遍历方式。先序，中序，后序，这个先中后指的是对父亲节点的访问顺序。三种遍历的概念都很简单，不再多提，在此主要总结一下三种遍历方式的代码实现。<br>下文中对每种遍历方式都提供了递归和迭代两种实现方式，相对而言，<strong>迭代比递归更加高效</strong>，递归会占用更多的内存空间，但是写法比迭代更加简洁、清晰，易于理解。所以在应用中追求高效时，应选择迭代的写法，若只是做做算法题或者更喜欢简洁的代码风格，可以使用递归写法。</p>
<hr>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>递归实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> res = [];   <span class="comment">//结果数组</span></span><br><span class="line">    preOrder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preOrder</span>(<span class="params">root, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;   <span class="comment">//递归边界</span></span><br><span class="line">    res.push(root.val);         <span class="comment">//在访问儿子节点之前将当前值插入res数组</span></span><br><span class="line">    preOrder(root.left, res);</span><br><span class="line">    preOrder(root.right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>迭代实现算法一：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> [];   </span><br><span class="line">    <span class="keyword">var</span> stack = [];     <span class="comment">//定义栈，用来存储节点</span></span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span> || stack.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;    </span><br><span class="line">            res.push(root.val);     <span class="comment">//先将当前节点值插入res数组</span></span><br><span class="line">            stack.push(root);       <span class="comment">//将当前节点压入栈</span></span><br><span class="line">            root = root.left;       <span class="comment">//访问当前节点的左儿子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop().right;   <span class="comment">//若当前节点为null，则将栈中最后一个节点出栈并访问其右儿子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>迭代实现算法二:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> stack = [root];</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> top = stack.pop();</span><br><span class="line">        res.push(top.val);</span><br><span class="line">        <span class="keyword">if</span> (top.right) &#123;    <span class="comment">//若有右儿子则压入栈</span></span><br><span class="line">            stack.push(top.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (top.left) &#123;     <span class="comment">//若有左儿子则压入栈</span></span><br><span class="line">            stack.push(top.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>递归实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    inorder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inorder</span>(<span class="params">root, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root.left, res);</span><br><span class="line">    res.push(root.val);      <span class="comment">//在访问左儿子节点之后，右儿子节点之前将当前值插入res数组</span></span><br><span class="line">    inorder(root.right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>迭代实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">var</span> stack = [root];</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> next = root.left;</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">null</span> || stack.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;     <span class="comment">//先访问到最左，并将沿途所有节点压入栈</span></span><br><span class="line">            stack.push(next);</span><br><span class="line">            next = next.left;</span><br><span class="line">        &#125;</span><br><span class="line">        next = stack.pop();        <span class="comment">//若当前节点为null，则将栈内最后一个节点赋给next</span></span><br><span class="line">        res.push(next.val);        <span class="comment">//将当前值插入res数组</span></span><br><span class="line">        next = next.right;         <span class="comment">//访问当前节点的右儿子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>递归实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    postOrder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postOrder</span>(<span class="params">root, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">    postOrder(root.left, res);</span><br><span class="line">    postOrder(root.right, res);</span><br><span class="line">    res.push(root.val);     <span class="comment">//在访问两个儿子节点之后将当前值插入res数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后序遍历的迭代实现是三种遍历方式里最为复杂的，需要添加一个额外的节点pre，用它来记录上一个访问的节点，以作判断。</p>
<p>迭代实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> stack = [root];</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="comment">//添加一个之前访问节点用作判断</span></span><br><span class="line">    <span class="keyword">var</span> pre = root;     </span><br><span class="line">    <span class="keyword">while</span> (stack.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//读取栈内的最后一个元素</span></span><br><span class="line">        node = stack[stack.length - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//若之前访问的节点不是当前节点的子节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre != node.left &amp;&amp; pre != node.right) &#123; </span><br><span class="line">            <span class="comment">//先添加右儿子，再添加左儿子</span></span><br><span class="line">            <span class="keyword">if</span> (node.right)  </span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span> (node.left)</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若当前节点无子节点，或者当前节点是之前访问节点的父节点，说明当前节点的子节点已经全部遍历完毕</span></span><br><span class="line">        <span class="keyword">if</span> ((node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) || pre == node.left || pre == node.right) &#123;</span><br><span class="line">            <span class="comment">//将当前节点值插入res数组</span></span><br><span class="line">            res.push(node.val);</span><br><span class="line">            <span class="comment">//当前节点出栈</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>递归算法简单好记，迭代算法高效但是语法较复杂，多看多记多理解。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/22/回溯法详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我摘青橘">
      <meta itemprop="description" content="不热爱写作的艺术家不是好程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘林">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/22/回溯法详解/" class="post-title-link" itemprop="url">回溯法详解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-22 10:00:00" itemprop="dateCreated datePublished" datetime="2019-03-22T10:00:00+08:00">2019-03-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-25 13:05:38" itemprop="dateModified" datetime="2019-03-25T13:05:38+08:00">2019-03-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>8皇后问题在算法界可谓是大名鼎鼎，无人不知无人不晓，同时它也是我本科生涯的一道拦路虎，在《动态规划入门》一文中提到笔者曾经数次在算法上知难而退，而八皇后问题就是数难之一了。当时并没有先学方法再来做题，而是试着从做题中领悟方法，但是个人能力又不强，决心也不够坚定，被难题打击几次，也就丢在一旁，没了兴趣。这次重新捡起算法，先学方法，再来看这道8皇后问题，竟然如此简单。这也是我应该反思的问题，<strong>学习方法永远比多刷两道题更重要</strong>。</p>
<p>在此我也建议刚接触算法的朋友， <strong>先学方法再做题</strong>，事半功倍。</p>
<p>言归正传，下面正式介绍解决8皇后问题所用的算法，也是经典的常用算法之一，回溯法。</p>
<hr>
<h3 id="回溯法简介"><a href="#回溯法简介" class="headerlink" title="回溯法简介"></a>回溯法简介</h3><p>回溯法可以描述为：在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>
<p>这样的描述乍眼一看肯定有些晦涩，首从例题和递归枚举算法说起吧。</p>
<hr>
<h3 id="递归枚举算法"><a href="#递归枚举算法" class="headerlink" title="递归枚举算法"></a>递归枚举算法</h3><p>首先来看一道LeetCode上的例题</p>
<p><img src="http://picbed.wzqj.top/picgo/20190322122748.png-wm" alt></p>
<p>看到题目，先考虑解法。我们可以把输入的序列分成两个部分，一部分是已经使用过的数字组成的有序序列A，剩下的是未使用过的数字按从小到大排列组成的序列S。可以写出伪代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permutation</span>(<span class="params">序列A，序列S</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(序列S为空)</span><br><span class="line">        输出序列A;</span><br><span class="line">    <span class="keyword">else</span> 依次考虑序列S中的每个元素v</span><br><span class="line">    &#123;</span><br><span class="line">        permutation(序列A的末尾+&#123;v&#125;，S-&#123;v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能理解伪代码的话那么写出程序代码也就不难了，在程序代码中，我们需要额外考虑的一个问题就是有哪些数字已经被使用过，使用过的数字不应被重复使用，为此，我们可以添加一个visit数组，用于进行标记。而有了visit数组后序列S就可以无需保存了，因为S可以由visit数组完全确定。<br>构造程序代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permute</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//首先将nums从小到大排序</span></span><br><span class="line">    nums.sort(); </span><br><span class="line">    <span class="comment">//构造标记数组，若该数已被使用则标1，未使用标0  </span></span><br><span class="line">    <span class="keyword">var</span> visited = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length).fill(<span class="number">0</span>);   </span><br><span class="line">    <span class="comment">//构造结果数组</span></span><br><span class="line">    <span class="keyword">var</span> res = [];   </span><br><span class="line">     <span class="comment">//构造中间值数组，对应序列A   </span></span><br><span class="line">    <span class="keyword">var</span> curArray = []; </span><br><span class="line">    <span class="comment">//递归入口</span></span><br><span class="line">    helper(nums, visited, curArray, res);   </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">nums, visited, curArray, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//若数组curArray的长度等于nums数组的长度意味着所有数字已经被添加，此时将序列保存到res数组中</span></span><br><span class="line">    <span class="keyword">if</span> (curArray.length == nums.length) &#123;</span><br><span class="line">        <span class="comment">//由于js的数组特性，此时添加的必须是curArray的复制</span></span><br><span class="line">        res.push(curArray.concat());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//依次遍历nums数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">//检查nums[i]是否已经添加过，若未添加则添加</span></span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//修改nums[i]对应的visit标记，并将其添加到curArray末尾</span></span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            curArray.push(nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//继续下一步递归</span></span><br><span class="line">            helper(nums, visited, curArray, res);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重要！这两步容易发生遗漏，遗漏则错</span></span><br><span class="line">            <span class="comment">//在对应的递归结束后修改其visit标记并将其从curArray末尾删去</span></span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">            curArray.splice(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信看到这里，读者们对于递归枚举算法已经有了认识了。</p>
<p><img src="http://picbed.wzqj.top/picgo/20190322133227.png-wm" alt></p>
<p>通过这道题我们可以认识一下解答树，上图是当nums为[1,2,3,4]时的前三层解答树，解答树显示出了递归函数的调用过程。这棵树的第k(0&lt;=k&lt;=n)层的每个节点有(k-n)个子节点，所以第n层的节点都没有子节点(即为叶子)，而每个叶子对应于一个排列，共有n!个叶子。<br>由于这棵树展示的是 <strong>“从什么都没做”逐步生成完整解的过程</strong>，因此将其称为解答树。</p>
<h3 id="回溯法例题"><a href="#回溯法例题" class="headerlink" title="回溯法例题"></a>回溯法例题</h3><p>接下来，我们做一道跟上题紧密相关的例题，在这里面我们就要首次用到回溯算法了。请看题。<br><img src="http://picbed.wzqj.top/picgo/20190322134502.png-wm" alt></p>
<p>这道题和第一道例题相比有两个区别：</p>
<ol>
<li>不再需要保存所有可能的序列，只需要返回序列的总和</li>
<li>给序列增加了筛选条件，要求 <strong>nums[i] % i ==0 || i % nums[i] == 0</strong></li>
</ol>
<p>可能这里有朋友会想到直接套用第一题的代码，等到 <strong>curArray.length == N</strong> 之后对curArray按位验算即可，如果每一位的数字均满足 <strong>nums[i] % i ==0 || i % nums[i] == 0</strong> 的话把总数+1即可。这样当然是可以的，但是这样会多出许多不必要的计算，因为如果当第二位就不满足条件的话，我们就没有必要继续往后计算了。</p>
<p><strong>因此，我们可以把生成和检查的过程有机结合起来，从而减少不必要的枚举，这也是回溯法的核心思想。</strong></p>
<p>写出算法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countArrangement</span>(<span class="params">N</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> visited = <span class="keyword">new</span> <span class="built_in">Array</span>(N + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    helper(N, visited, <span class="number">1</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; N</span></span><br><span class="line"><span class="comment"> * @param &#123;array&#125; visited 标记数组，用于记录数字是否被使用过</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; pos 当前下标</span></span><br><span class="line"><span class="comment"> * @param &#123;array&#125; res 结果数组，在这里使用array来保存结果是为了方便引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">N, visited, pos, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; N) &#123;      </span><br><span class="line">        res[<span class="number">0</span>]++;   <span class="comment">//当一组序列确定后，结果数+1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; (i % pos == <span class="number">0</span> || pos % i == <span class="number">0</span>)) &#123;    <span class="comment">//条件筛选</span></span><br><span class="line">            visited[i] = <span class="number">1</span>;    <span class="comment">//满足条件则修改标记数组</span></span><br><span class="line">            helper(N, visited, pos + <span class="number">1</span>, res);   <span class="comment">//进一步递归</span></span><br><span class="line">            visited[i] = <span class="number">0</span>;    <span class="comment">//切记某一步递归结束之后应还原数据！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当N为4时，部分解答树如下所示</p>
<p><img src="http://picbed.wzqj.top/picgo/20190325111048.png-wm" alt></p>
<p>从图中可以看到，由于我们将生成和检查的过程结合了起来，当运行到图中的红色节点时，由于不满足筛选条件，算法将不会继续向下运算，而是向上回溯。这就是回溯算法。因此另一方面，<strong>我们可以将回溯法理解为搜索+剪枝</strong>。</p>
<hr>
<h3 id="8皇后问题"><a href="#8皇后问题" class="headerlink" title="8皇后问题"></a>8皇后问题</h3><p>接下来要讲的就是回溯法的经典问题——8皇后问题，问题描述如下：<br>在8*8的棋盘上防止8个皇后，使得它们互不攻击，每个皇后的攻击范围是同行同列和同对角线，要求找出解的总数。下图所示为一个可行解。<br><img src="http://picbed.wzqj.top/picgo/20190325112410.png-wm" alt></p>
<p>问题分析：</p>
<ol>
<li>最简单的思路就是把问题转化为”从64个格子中选8个”，这是组合生成问题，根据组合数学，有 $C_{64}^{8}=4.426 \times 10^{9}$ 种方案，这不够友好</li>
<li>经过思考不难发现以下事实：恰好每行每列各放置一个皇后，如果用C[x]表示第x行皇后的列编号，则问题被转化为全排列生成问题，而0-7的排列一共只有 $8!=40320$ 个，枚举量不会超过它</li>
</ol>
<p>由于N皇后问题更具有普适性，且与8皇后问题算法思想一致（代入n=8即为8皇后问题），故在此给出N皇后问题js算法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> totalNQueens = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> C = [];</span><br><span class="line">    computeNQueens(n, <span class="number">0</span>, C, res);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeNQueens</span>(<span class="params">n, cur, C, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == n) &#123;    <span class="comment">//递归边界，若走到此处则说明所有皇后均不冲突，结果数+1</span></span><br><span class="line">        res[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//尝试把第cur行的皇后放在第i列</span></span><br><span class="line">        C[cur] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; cur; j++) &#123;</span><br><span class="line">            <span class="comment">//检查同列、主对角线和副对角线，这样写的作用在后文会说明 </span></span><br><span class="line">            <span class="keyword">if</span> (C[cur] == C[j] || cur - C[cur] == j- C[j]  || cur + C[cur] == j + C[j])   </span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)  <span class="comment">//若有效则继续向下一行递归</span></span><br><span class="line">            computeNQueens(n, cur + <span class="number">1</span>, C, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时这也是LeetCode 52. N皇后 II问题的题解。</p>
<p>本题难以理解之处在于对皇后位置的筛选。在代码中我们使用语句 </p>
<p><code>C[cur] == C[j] || C[cur] - cur == C[j] - j || C[cur] + cur == C[j] + j</code> </p>
<p>来进行筛选，由于我们是逐行添加，所以皇后肯定不会横向攻击，因此只需要检查纵向和斜向攻击即可。</p>
<p>条件 <code>C[cur] == C[j]</code>用来检查判断皇后(cur,C[cur])和皇后(j,C[j])是否在同一列上<br>条件 <code>cur - C[cur] == j- C[j]  || cur + C[cur] == j + C[j]</code> 则用来检查皇后(cur,C[cur])和皇后(j,C[j])是否在同一对角线上，原理可以用下图来说明</p>
<p><img src="http://picbed.wzqj.top/picgo/20190325122254.png-wm" alt><img src="http://picbed.wzqj.top/picgo/20190325122635.png-wm" alt></p>
<p>至此，8皇后问题就有了一个详细的求解过程，算法其实可以进一步优化，比如使用一个二维数组直接判断当前尝试的皇后所在列和两个对角线是否已经有了其他皇后，在此我就不再继续深入了。有兴趣的同学可以尝试自己画一下4皇后或者5皇后问题的解答树，看看有哪一步往下搜索了，又有哪一步进行了回溯，加深理解。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>阅读到此，相信各位已经对回溯算法和8皇后问题有了基本的认识。就我自己的理解，回溯算法就是将生成和检查结合在了一起，通过筛选避免了大量不必要的计算，也就是搜索+剪枝。</p>
<p>感谢阅读！</p>
<hr>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote>
<p><a href="https://blog.csdn.net/weiyuefei/article/details/79316653" target="_blank" rel="noopener">https://blog.csdn.net/weiyuefei/article/details/79316653</a><br><a href="https://www.cnblogs.com/wuyuegb2312/p/3273337.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuyuegb2312/p/3273337.html</a><br>《算法竞赛入门经典》——刘汝佳</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/11/动态规划入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我摘青橘">
      <meta itemprop="description" content="不热爱写作的艺术家不是好程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘林">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/11/动态规划入门/" class="post-title-link" itemprop="url">动态规划入门</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-11 19:00:00" itemprop="dateCreated datePublished" datetime="2019-03-11T19:00:00+08:00">2019-03-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-12 15:50:16" itemprop="dateModified" datetime="2019-03-12T15:50:16+08:00">2019-03-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对每个计算机专业学生而言，算法都是绕不过去的坎，本科的时候曾经对算法很好奇，也数次下决心要学好算法，往往从简单题做起，开始还开开心心觉得挺轻松，到后面难题的时候就停滞不前，最后也就知难而退。到了求职的时候，算法还是要重新捡起，所以在此对一些算法概念进行归类和总结，这是本科的时候没有做的。就像做数学题一样，碰到一道题首先要知道这题是考什么，这样才有方向。这几天正好碰到动态规划的题型，于是就从动态规划写起。</p>
<hr>
<h3 id="从例题说起"><a href="#从例题说起" class="headerlink" title="从例题说起"></a>从例题说起</h3><p>直接从概念说起的话显然不是那么好理解，就从一道简单的例题说起吧（例题取自LeetCode），题目描述如下所示。<br><img src="http://picbed.wzqj.top/picgo/20190312144620.png-wm" alt></p>
<p>题目并不难，从图中两个示例可以看出2级和3级台阶时分别有2种和3种方法爬到楼顶，那么4级台阶呢？</p>
<p>显然，对于一个新的台阶数，最后一步无非就是走一级或者走两级。</p>
<ol>
<li>第一种情况，最后一步走一级台阶，那么只需要求前面3级有多少种走法，是不是相当于求示例2？</li>
<li>第二种情况，最后一步走两级台阶，那么只需求要前面2级有多少种解法，是不是相当于求示例1？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即 f(4) = f(3) + f(2)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以此类推：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(5) = f(4) + f(3)</span><br><span class="line">f(6) = f(5) + f(4)</span><br><span class="line">……</span><br><span class="line">f(n) = f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure></p>
<p>没错，这和大家熟悉的费波纳茨(Fibonacci)数列非常相似，这也是这道题的核心算法。现在有了算法，我们可以尝试去写一下代码。</p>
<p>首先，我们很容易就可以写出例题对应的递归算法，这里为了后面比较方便，在主函数中另写了一个计算函数，大家只要比较计算函数的不同即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = caculator(n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caculator</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">return</span> caculator(n - <span class="number">1</span>) + caculator(n - <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>递归的算法写起来很简单，但是在提交的时候却显示超时，为什么呢？</p>
<p><img src="http://picbed.wzqj.top/picgo/20190312151331.png-wm" alt></p>
<p>原因就是我们在递归中进行了大量的重复计算。从上图可知，我们计算f(5)时计算了两次f(3)，3次f(2)。当n越大时，需要重复计算的值越多，大量的重复计算给算法性能带来了极大的影响，造成算法超时。</p>
<p>如果我们把已经计算过的结果保存起来，当需要使用时直接返回，这样是不是就可以避免大量的重复计算？算法改进如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]       <span class="comment">//定义一个数组存储计算的值</span></span><br><span class="line">    <span class="keyword">var</span> res = caculator(a, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caculator</span>(<span class="params">a, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[n] != <span class="literal">undefined</span>) &#123;    <span class="comment">//如果数组中的对应位置已经有值，说明已经计算过，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> a[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        a[n] = n;</span><br><span class="line">        <span class="keyword">return</span> a[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[n] = caculator(a, n - <span class="number">1</span>) + caculator(a, n - <span class="number">2</span>)    <span class="comment">//有新值被计算出时保存到对应的位置</span></span><br><span class="line">        <span class="keyword">return</span> a[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用一个数组来保存每次计算出的值，当有重复计算时，直接返回对应的值，这样就可以节约大量的重复计算时间，提交之后果然AC。</p>
<p>进一步思考，我们需要保存每一次计算出来的值吗？<br>而且之前的计算全部都是由上往下的，从 n 到n-1、n-2, n-1到n-2、n-3，一直计算到1为止。如果我们采用从下往上计算呢？</p>
<p>由此我们可以进一步优化算法的内存占用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = caculator(n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caculator</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        [a, b] = [b, a + b];    <span class="comment">//从下往上计算，每次保存最新的两个值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终，可以通过优化语法，达到下面的简洁效果<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一般来说由于从上往下的动态规划方法使用了递归，递归的时候会产生额外的开销，使用自底向上的动态规划方法要比从上往下的方法好。 </p>
<p>至此，相信大家对于动态规划已经有了初步的了解，动态规划的核心就是 <strong>记住已经计算过的解</strong>。</p>
<hr>
<h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><p>动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p>
<p>动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
<p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p>
<hr>
<h3 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h3><p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<ol>
<li><p>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
</li>
<li><p>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
</li>
<li><p>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的算法简介和适用情况摘自百度百科，第一遍看可能云里雾里，但是结合前面的例题再回来看就会有所收获。在此我说说看我对动态规划算法的理解。<br>动态规划算法的解题过程就是 <strong>将问题分解成重叠子问题，找到其中的转化关系，并且记住已经求过的子问题的解，使用子问题的解去计算母问题的解</strong>。<br>例题中的转化关系就是 <strong>f(n) = f(n-1) + f(n-2)</strong> ，找到了这个转化关系就有了计算思路，在最终的算法中我们也使用了一个数组去 <strong>记住子问题的解</strong> ，并使用 <strong>子问题的解</strong> 一级一级向上计算，直到求出 <strong>母问题的解</strong>，通过保存子问题的解从而避免了大量的重复计算，达到改善性能的效果。</p>
<p>动态规划算法也并非完全像例题中所讲解的那么简单，还有许多复杂的应用情况，这篇文章仅作为入门文章，不再深入，若之后有需要会另写博客以作说明。</p>
<hr>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote>
<p><a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">https://blog.csdn.net/u013309870/article/details/75193592</a><br><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin</a><br>《算法竞赛入门经典》 —— 刘汝佳</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/使用七牛云 + PicGo搭建图床并实现快速上传/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我摘青橘">
      <meta itemprop="description" content="不热爱写作的艺术家不是好程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘林">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/使用七牛云 + PicGo搭建图床并实现快速上传/" class="post-title-link" itemprop="url">使用七牛云 + PicGo搭建图床并实现图片便捷上传</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-01 14:30:00 / 修改时间：16:32:36" itemprop="dateCreated datePublished" datetime="2019-03-01T14:30:00+08:00">2019-03-01</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前两天使用Github Pages + Hexo搭建了个人博客，并使用 markdown 格式写了第一篇文章，在使用时发现 markdown 格式的图片并非像 word 格式一样直接复制在文件上，而是通过链接的方式将图片的本地地址或者网络地址写在md文件相应的位置，而 mrakdown 编辑器会自动去相应地址加载图片。</p>
<p>我第一次将md文件上传到阿里云时并没有将所对应的图片上传，导致从浏览器打开时图片位置全是显示错误。然后在网上找到了初步的<a href="https://blog.csdn.net/qq_38148394/article/details/79997971" target="_blank" rel="noopener">解决办法</a>，但是这样需要每次将文章内的图片同步上传到服务器，对本就空间不大的阿里云服务器来说是不小的压力，根据大学室友(七牛骨干研发)的建议，使用七牛云搭建图床，七牛每个月可以提供10G的免费流量，然后在知乎上看到不少人推荐使用PicGo作为图片上传工具，下载使用了一下，虽然设置时出了一点小问题花了一些时间，但是使用体验良好。遂也在此推荐一下，并将搭建图床及软件配置过程记录，以作分享。</p>
<hr>
<h3 id="何为图床"><a href="#何为图床" class="headerlink" title="何为图床"></a>何为图床</h3><p>什么是图床？之前我对于图床也是只是听说过，单对于图床到底是什么却不甚了解。</p>
<blockquote>
<p>图床一般是指储存图片的服务器 —— baidu</p>
<p>图床指带有外链服务的网络相册 —— wiki</p>
</blockquote>
<p>以上是百度百科和维基百科对于图床的定义，有趣的是，在中文维基中搜索图床会被重定向至词条“网络相册”，上面的定义也是我根据维基的表述总结而成。总而言之，图床就是一个专门用于存储图片的存储空间，可以通过外链的方式进行分享。</p>
<hr>
<h3 id="创建七牛云图床"><a href="#创建七牛云图床" class="headerlink" title="创建七牛云图床"></a>创建七牛云图床</h3><ol>
<li>创建七牛云账号</li>
<li>上传身份证正反面照片进行实名认证</li>
<li>创建对象存储空间<br><img src="http://picbed.wzqj.top/picgo/20190301152911.png-wm" alt><br>存储空间名字不分大小写，就算含有大写字母创建时也会自动转为小写。存储区域选择离自己所在地较近的就行，访问控制选择公开空间，毕竟wiki也说了要带有外链服务以供分享，填写完后点击确定创建即可。<br>创建完成后主页如下所示。<br><img src="http://picbed.wzqj.top/picgo/20190301154237.png-wm" alt><br>因为此图为完成后所截，所以域名和图片处理两块和刚创建时不太一样，这个后面会提到。</li>
</ol>
<h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>因为七牛提供的测试域名仅有30天有效期，所以我绑定了我自己的域名，并使用picbed作为前缀。在主页点击添加自定义域名<br><img src="http://picbed.wzqj.top/picgo/20190301154642.png-wm" alt><br>添加后七牛会提供CNAME地址<br><img src="http://picbed.wzqj.top/picgo/20190301154748.png-wm" alt><br>鼠标悬浮在上即可查看。<br>接下来到域名提供商处添加CNAME解析记录，这一步在《linux下使用 Github Pages + Hexo 搭建个人博客》文中提到过，不再重复。<br>添加解析记录后回到主页，点击内容管理，修改外链默认域名并保存。<br><img src="http://picbed.wzqj.top/picgo/20190301155831.png-wm" alt></p>
<hr>
<h3 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h3><p>因为毕竟是用于自己博客的图床，给图片添加水印可以稍微缓解图片被盗用的情况。在存储空间主页点击图片样式，并点击新建图片样式。里面的设置都很简单，相信大家看到界面都会进行操作，不再赘述。将图片样式保存后，可以试验一下效果。</p>
<p>回到存储空间主页，点击内容管理，并选择一张图片上传，上传后复制外链。<br><img src="http://picbed.wzqj.top/picgo/20190301155937.png-wm" alt><br>打开浏览器，将外链复制到地址栏，并在后加上“-”以及样式名称。<br><img src="http://picbed.wzqj.top/picgo/20190301160214.png-wm" alt><br>我的样式名称保存为wm，所以只需要加上-wm即可，若一切顺利，浏览器便能够正常显示附带水印后的图片。</p>
<hr>
<h3 id="下载并配置PicGo"><a href="#下载并配置PicGo" class="headerlink" title="下载并配置PicGo"></a>下载并配置PicGo</h3><ol>
<li>下载地址： <a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a> ，windows用户下载页面中的exe版本即可。<br><br></li>
<li>下载安装后打开，在图床设置中对七牛图床进行设置，设置图如下<br><img src="http://picbed.wzqj.top/picgo/20190301160935.png-wm" alt><br>两个Key作为连接凭证，可以在七牛云的个人面板-秘钥管理中查看，复制过来即可。设定访问网址必须添加<a href="http://或https://，不然无效。输入完后点击确定并设为默认图床。" target="_blank" rel="noopener">http://或https://，不然无效。输入完后点击确定并设为默认图床。</a><br>注意：我在这一步出现了一个小问题，我的所有项全部填写正确，但是在上传图片时报错，显示找不到对应的存储空间，反复填写多次依然没用。后面把存储空间和网址改为其他地址，并点击确定后再重新改为我之前的地址，最终可以正常上传。不知道其他人是否遇到，遇到的话可以这样做试试。<br><br></li>
<li>修改自定义链接格式，在后面添加”-wm”后缀，并在上传区中的链接格式中选择Custrom。设置之后返回的外链链接就会自动添加”-wm”后缀实现水印效果。<br><img src="http://picbed.wzqj.top/picgo/20190301162727.png-wm" alt></li>
</ol>
<p><br></p>
<ol>
<li>配置好之后到PicGo的上传区，PicGo支持选择文件上传以及拖动文件上传，也可以缩成一个桌面上的小球，将图片拖动到小球中即可上传。不过我最常用的还是剪切图片后使用快捷键上传，可以在设置中对快捷键进行设置。图片上传之后会自动将外链复制到粘贴板，直接粘贴即可使用。</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>进行至此，整个流程也算结束了，操作起来并不复杂，甚至还挺简单。除了七牛云之外，腾讯云据说也很不错，我也创建了一个存储空间，但是还未投入使用。有兴趣的朋友可以去试试，同样可以和PicGo进行绑定实现便捷上传。<br>最后的最后，祝大家使用愉快，周末愉快！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/26/linux下使用-Github-Pages-Hexo-搭建个人博客/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我摘青橘">
      <meta itemprop="description" content="不热爱写作的艺术家不是好程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘林">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/26/linux下使用-Github-Pages-Hexo-搭建个人博客/" class="post-title-link" itemprop="url">linux下使用 Github Pages + Hexo 搭建个人博客</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-26 21:40:32" itemprop="dateCreated datePublished" datetime="2019-02-26T21:40:32+08:00">2019-02-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-01 21:22:38" itemprop="dateModified" datetime="2019-03-01T21:22:38+08:00">2019-03-01</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　想搭个博客的想法已经存在很久了。笔者自认是个学习速度尚可但是忘性较大的”效率型”人才，可能两天学会了一项新技术，但是一个月不用，又和没学过差不了太多。代码亦是如此，看书全都会，没书写不来。于是在学会什么新事物后自己再做个总结归纳，强化记忆，益处无穷。之前做笔记用的是OneNote，不支持 <strong><em>markDown</em></strong> 格式，而且也不方便随时随地翻阅，逼格也不够高，借此机会，使用Github Pages + Hexo 在阿里云（学生价）上搭了一个小型的个人博客，并映射到之前购买的私有域名，照着多方教程一路磕磕碰碰，总体还算顺利，也将此作为博客的开始，写下第一篇博文。</p>
<hr>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>如何租赁服务器和购买域名，以及域名备案，阿里云的官网已经介绍得很详细了，而且网上也有很多教程分享，在此不再赘述。服务器设置好之后安装 <a href="https://www.cnblogs.com/kevinchou/p/5405540.html" target="_blank" rel="noopener">NodeJs和NPM</a>。</p>
<hr>
<h3 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h3><h4 id="服务器安装git"><a href="#服务器安装git" class="headerlink" title="服务器安装git"></a>服务器安装git</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
<h4 id="新建Git仓库"><a href="#新建Git仓库" class="headerlink" title="新建Git仓库"></a>新建Git仓库</h4><ol>
<li>登录/注册: <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br><br></li>
<li>创建新仓库且 <strong>Respository name</strong> 中一定要输入：你的用户名+’.github.io’<br> <img src="http://picbed.wzqj.top/picgo/1.png-wm" alt="1"></li>
<li><p>生成ssh key</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd: /       #进入根目录</span><br><span class="line">mkdir: /.ssh        #创建隐藏文件夹.ssh</span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p> 未设密码，一路回车，最后会在/.ssh/下生成两个ssh key</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p> 进入GitHub个人设置页面，点击SSH and GPGkeys 添加一个==SSH key==，标题可以随便，内容复制以下命令的输出：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p> <img src="http://picbed.wzqj.top/picgo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190226181445.png-wm" alt="2"></p>
<p> 这样SSH就配置好了，配置一下git</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “xxx” </span><br><span class="line">git config --global user.email “xxx@xxx.com”</span><br></pre></td></tr></table></figure>
<p> 连接测试</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="搭建Hexo"><a href="#搭建Hexo" class="headerlink" title="搭建Hexo"></a>搭建Hexo</h4><ol>
<li><p>安装Hexo</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>定位到你想存放博客的位置,笔者存放在根目录下的blog文件夹</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br><span class="line">mkidr blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure>
</li>
<li><p>Hexo初始化</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init 你的用户名.github.io  // 建议和创建仓库时使用同一个</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装服务</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 你的用户名.github.io</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h4><p>Hexo搭建完成后目录下有_config.yml 文件，也就是Hexo的配置文件，打开并修改。（笔者使用Xftp6 + VS Code打开）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">title: xxx  # 博客的名字，也称站点名称</span><br><span class="line"></span><br><span class="line">author: xxx # 作者名字</span><br><span class="line"></span><br><span class="line">description: xxx # 对站点的描述，搜索引擎会抓取，可以自定义（这个还是加上比较好）</span><br><span class="line"></span><br><span class="line">language: zh-CN # 语言 简体中文</span><br><span class="line">#此值取决于themes文件夹下各主题中language文件夹内的中文文件命名</span><br><span class="line">#默认的landscape主题中language文件夹下中文为zh-CN.yml</span><br><span class="line"></span><br><span class="line">theme: landscape  # 配置主题</span><br><span class="line"></span><br><span class="line">deploy: # 部署相关配置</span><br><span class="line">    type: git # 使用 Git 提交</span><br><span class="line">    repo: git@github.com:xxx/xxx.github.io # 就是存放博客的仓库地址</span><br></pre></td></tr></table></figure></p>
<p>完整配置文档请前往<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">Hexo官方文档</a></p>
<p>至此，个人博客配置基本完成，可以尝试先在本地运行。</p>
<ol>
<li>定位到xxx.github.io目录<br><br></li>
<li><p>启动测试<br> 输入命令</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   #清除缓存 网页正常情况下可以忽略此条命令</span><br><span class="line">hexo g       #即hexo generate，生成静态文件夹</span><br><span class="line">hexo s       #即hexo server，启动本地预览</span><br></pre></td></tr></table></figure>
<p> <img src="http://picbed.wzqj.top/picgo/2.png-wm" alt="3"></p>
<p> 此时再开一个ssh链接，之前链接中的测试不要关，用新开的链接浏览网站</p>
<p> 安装elinks<br> <code>sudo apt-get install elinks</code>;<br> 使用命令<br> <code>elinks --dump http://localhost:4000</code> 可以访问生成的网站<br><br></p>
</li>
<li><p>发布到GitHub Pages<br> 输入命令</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d      #即hexo deploy，部署到git</span><br></pre></td></tr></table></figure>
<p> 如果是第一次部署，终端会提示要求输入用户名和密码。等命令执行完之后，过几分钟打开 <a href="http://xxx.github.io" target="_blank" rel="noopener">http://xxx.github.io</a> 即可看到你的个人博客了。如果以后要发布新文章，文章的md文件放在xxx.github.io的_posts文件夹下再重新执行上述几条命令即可。<br><br></p>
</li>
<li>注意<br> 如果发布时报错 ERROR Deployer not found: git<br> 输入命令<code>npm install --save hexo-deployer-git</code>即可</li>
</ol>
<h3 id="绑定到私有域名"><a href="#绑定到私有域名" class="headerlink" title="绑定到私有域名"></a>绑定到私有域名</h3><p>进行到这里，基本的雏形已经有了，下面就可以把搭建好的博客绑定到我们的私有域名。<br>首先进入阿里云的域名管理。<br><img src="http://picbed.wzqj.top/picgo/3.png-wm" alt="4"><br>点击解析，添加记录如下<br><img src="http://picbed.wzqj.top/picgo/4.png-wm" alt="5"></p>
<p>添加完成之后回到 xxx.github.io/source 目录下,新建文件CNAME，无需后缀名，文件内容写入你的私有域名即可。<br><img src="http://picbed.wzqj.top/picgo/5.png-wm" alt="6"><br>再次说明：图片是我用记事本打开，但是文件本身无后缀名，勿添加txt结尾。<br>进行到此，再重复一遍上面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p>
<p>使用浏览器打开域名地址，大功告成！<br><br><br><img src="http://picbed.wzqj.top/picgo/6.png-wm" alt="7"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到此为止第一篇博文也就基本结束了，也是第一次使用makedown语法写作，毫不夸张地说，也算是笔者自五年前进入本科计算机专业后的第一次半文学创作吧（毕业论文除外），写得也很认真，搭博一小时，写作三小时，由于是第一次使用makedown，语法和一些细节处理得不算好，请多见谅。闲话也不再多说，就让这篇文章在此结束吧。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://blog.csdn.net/cdl2008sky/article/details/79011852" target="_blank" rel="noopener">https://blog.csdn.net/cdl2008sky/article/details/79011852</a><br><a href="https://blog.csdn.net/weixin_36401046/article/details/52940313" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36401046/article/details/52940313</a><br><a href="https://blog.csdn.net/ctsas/article/details/73694849" target="_blank" rel="noopener">https://blog.csdn.net/ctsas/article/details/73694849</a><br><a href="https://blog.csdn.net/Wonz5130/article/details/82828761" target="_blank" rel="noopener">https://blog.csdn.net/Wonz5130/article/details/82828761</a><br><a href="https://www.jianshu.com/p/380290deb8f0" target="_blank" rel="noopener">https://www.jianshu.com/p/380290deb8f0</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">我摘青橘</p>
              <p class="site-description motion-element" itemprop="description">不热爱写作的艺术家不是好程序员</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<div>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">总访问量  <span id="busuanzi_value_site_pv"></span></span>
    <span class="post-meta-divider"></span>
</div>


<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我摘青橘</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.0</div>






        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  



  




  

  

  
  

  
  
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow-x: scroll;
  overflow-y: hidden;
}
</style>

    
  


  

  

  

  

  

  

  

  

  

  

</body>
</html>
